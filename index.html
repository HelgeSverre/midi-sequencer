<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Step Sequencer</title>
    <script
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
      defer
    ></script>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #f0f0f0;
        --primary-color: #fd9c21;
        --secondary-color: #22f3d3;
        --control-bg: #3a3a3a;
        --step-border: #4a4a4a;
        --top-controls-bg: #2a2a2a;
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        font-family: "Arial", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        box-sizing: border-box;
      }

      .top-controls {
        background-color: var(--top-controls-bg);
        padding: 10px;
        display: flex;
        justify-content: flex-start;
        gap: 15px;
        flex-wrap: wrap;
      }

      .sequencer {
        flex-grow: 1;
        overflow-y: auto;
        padding: 20px 10px;
      }

      button,
      select {
        background-color: var(--control-bg);
        color: var(--text-color);
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s;
        border-radius: 5px;
      }

      button:hover,
      select:hover {
        background-color: #505050;
        transform: translateY(-2px);
      }

      button.active {
        background-color: var(--primary-color);
        color: var(--bg-color);
      }

      input[type="number"] {
        background-color: var(--control-bg);
        color: var(--text-color);
        border: none;
        padding: 12px;
        font-size: 16px;
        border-radius: 5px;
        width: 80px;
      }

      .lane {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 15px;
        margin-bottom: 15px;
      }

      .lane-controls {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 200px;
      }

      .steps {
        display: grid;
        grid-template-columns: repeat(16, 1fr);
        gap: 5px;
        flex-grow: 1;
      }

      .step {
        height: 50px;
        border: 2px solid var(--step-border);
        cursor: pointer;
        transition: all 0.3s;
        border-radius: 5px;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }

      .step.active {
        background-color: var(--primary-color);
        color: var(--bg-color);
        box-shadow: 0 0 10px rgba(253, 156, 33, 0.5);
      }

      .step.current {
        border-color: var(--secondary-color);
        box-shadow: 0 0 10px rgba(34, 243, 211, 0.5);
      }

      .step-velocity {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.3);
      }

      .chord-editor {
        position: absolute;
        background-color: var(--control-bg);
        border: 1px solid var(--primary-color);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
      }

      .chord-note {
        display: inline-block;
        margin: 2px;
        padding: 5px;

        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 3px;
        cursor: pointer;
      }

      .chord-note.active {
        background-color: var(--primary-color);
        color: var(--bg-color);
      }
    </style>
  </head>
  <body x-data="app">
    <div class="container">
      <div class="top-controls">
        <button @click="togglePlay()" :class="{ active: isPlaying }">
          <span x-text="isPlaying ? 'Pause' : 'Play'"></span>
        </button>
        <button @click="stop()">Stop</button>
        <button @click="toggleRecord()" :class="{ active: isRecording }">
          <span x-text="isRecording ? 'Stop Recording' : 'Record'"></span>
        </button>
        <label>
          BPM:
          <input
            type="number"
            x-model="bpm"
            min="1"
            max="300"
            @change="updateBpm"
          />
        </label>
        <button @click="addLane()">Add Lane</button>
        <button @click="clearAll()">Clear All</button>
      </div>
      <div class="sequencer">
        <template x-for="(lane, laneIndex) in sequences" :key="laneIndex">
          <div class="lane">
            <div class="lane-controls">
              <select
                x-model="midiInputSelections[laneIndex]"
                @change="updateMidiInput(laneIndex)"
              >
                <option value="">No Input</option>
                <template x-for="(input, index) in midiInputs" :key="index">
                  <option :value="index" x-text="input.name"></option>
                </template>
              </select>
              <select
                x-model="midiOutputSelections[laneIndex]"
                @change="updateMidiOutput(laneIndex)"
              >
                <option value="">No Output</option>
                <template x-for="(output, index) in midiOutputs" :key="index">
                  <option :value="index" x-text="output.name"></option>
                </template>
              </select>
              <select
                x-model="lane.midiChannel"
                @change="updateMidiChannel(laneIndex)"
              >
                <template x-for="channel in 16" :key="channel">
                  <option
                    :value="channel"
                    x-text="`Channel ${channel}`"
                  ></option>
                </template>
              </select>
            </div>
            <div class="steps">
              <template
                x-for="(step, stepIndex) in lane.steps"
                :key="stepIndex"
              >
                <div
                  class="step"
                  :class="{
                                'active': step !== null,
                                'current': stepIndex === currentStep
                            }"
                  @click="openChordEditor(laneIndex, stepIndex)"
                >
                  <div
                    x-show="step !== null"
                    class="step-velocity"
                    :style="{ height: (step ? step.velocity * 100 : 0) + '%' }"
                  ></div>
                  <span x-text="getStepDisplay(step)" class="step-note"></span>
                </div>
              </template>
            </div>
            <button @click="clearLane(laneIndex)">Clear</button>
            <button @click="cloneLane(laneIndex)">Clone</button>
            <button @click="removeLane(laneIndex)">Remove</button>
          </div>
        </template>
      </div>

      <!-- Chord Editor -->
      <div
        x-show="chordEditorOpen"
        class="chord-editor"
        :style="{ top: chordEditorPosition.y + 'px', left: chordEditorPosition.x + 'px' }"
      >
        <h3>Edit Chord/Notes</h3>
        <div>
          <template
            x-for="note in [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71]"
          >
            <span
              class="chord-note"
              :class="{ 'active': isNoteInChord(note) }"
              x-text="getNoteNameFromMidiNumber(note)"
              @click="toggleNoteInChord(note)"
            ></span>
          </template>
        </div>
        <label>
          Velocity:
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            x-model="editingStep.velocity"
          />
        </label>
        <button @click="saveChord">Save</button>
        <button @click="closeChordEditor">Cancel</button>
      </div>
    </div>

    <script>
      document.addEventListener("alpine:init", () => {
        Alpine.data("app", () => ({
          isPlaying: false,
          isRecording: false,
          bpm: 120,
          currentStep: 0,
          sequences: [{ midiChannel: 1, steps: Array(16).fill(null) }],
          lastStepTime: performance.now(),
          midiAccess: null,
          midiInputs: [],
          midiOutputs: [],
          midiInputSelections: [""],
          midiOutputSelections: [""],
          midiStatus: "MIDI not initialized",
          chordEditorOpen: false,
          chordEditorPosition: { x: 0, y: 0 },
          editingLaneIndex: null,
          editingStepIndex: null,
          editingStep: { notes: [], velocity: 0.7 },

          async init() {
            await this.initMidi();
            this.startUpdateLoop();
          },

          async initMidi() {
            try {
              this.midiAccess = await navigator.requestMIDIAccess();
              this.midiInputs = Array.from(this.midiAccess.inputs.values());
              this.midiOutputs = Array.from(this.midiAccess.outputs.values());
              this.midiStatus = "MIDI initialized successfully";
            } catch (err) {
              console.error("Could not access MIDI devices:", err);
              this.midiStatus = "Failed to initialize MIDI";
            }
          },

          startUpdateLoop() {
            const update = () => {
              if (this.isPlaying) {
                const currentTime = performance.now();
                const msPerStep = 60000 / this.bpm / 4; // Assuming quarter notes
                if (currentTime - this.lastStepTime >= msPerStep) {
                  this.playStep();
                  this.currentStep = (this.currentStep + 1) % 16;
                  this.lastStepTime = currentTime;
                }
              }
              requestAnimationFrame(update);
            };
            update();
          },

          togglePlay() {
            this.isPlaying = !this.isPlaying;
            if (this.isPlaying) {
              this.lastStepTime = performance.now();
            }
          },

          stop() {
            this.isPlaying = false;
            this.currentStep = 0;
            this.allNotesOff();
          },

          toggleRecord() {
            this.isRecording = !this.isRecording;
          },

          openChordEditor(laneIndex, stepIndex) {
            const rect = event.target.getBoundingClientRect();
            this.chordEditorPosition = {
              x: rect.left,
              y: rect.bottom + window.scrollY,
            };
            this.editingLaneIndex = laneIndex;
            this.editingStepIndex = stepIndex;
            this.editingStep = this.sequences[laneIndex].steps[stepIndex] || {
              notes: [],
              velocity: 0.7,
            };
            this.chordEditorOpen = true;
          },

          closeChordEditor() {
            this.chordEditorOpen = false;
          },

          isNoteInChord(note) {
            return this.editingStep.notes.includes(note);
          },

          toggleNoteInChord(note) {
            const index = this.editingStep.notes.indexOf(note);
            if (index > -1) {
              this.editingStep.notes.splice(index, 1);
            } else {
              this.editingStep.notes.push(note);
            }
          },

          saveChord() {
            if (this.editingStep.notes.length > 0) {
              this.sequences[this.editingLaneIndex].steps[
                this.editingStepIndex
              ] = this.editingStep;
            } else {
              this.sequences[this.editingLaneIndex].steps[
                this.editingStepIndex
              ] = null;
            }
            this.closeChordEditor();
          },

          getStepDisplay(step) {
            if (!step || step.notes.length === 0) return "";
            if (step.notes.length === 1)
              return this.getNoteNameFromMidiNumber(step.notes[0]);
            return `Chord (${step.notes.length})`;
          },

          playStep() {
            this.sequences.forEach((lane, laneIndex) => {
              const step = lane.steps[this.currentStep];
              if (step && step.notes.length > 0) {
                step.notes.forEach((note) => {
                  this.sendMidiNote(laneIndex, note, step.velocity);
                });
              }
            });
          },

          sendMidiNote(laneIndex, note, velocity) {
            const outputIndex = this.midiOutputSelections[laneIndex];
            if (outputIndex !== "") {
              const output = this.midiOutputs[outputIndex];
              const channel = this.sequences[laneIndex].midiChannel - 1;
              output.send([0x90 + channel, note, Math.round(velocity * 127)]); // Note On
              setTimeout(() => {
                output.send([0x80 + channel, note, 0]); // Note Off
              }, 100); // Note duration
            }
          },

          handleMidiMessage(message, laneIndex) {
            if (this.isRecording) {
              const [status, note, velocity] = message.data;
              if (status >= 144 && status <= 159 && velocity > 0) {
                // Note On, any channel
                const currentStep = this.sequences[laneIndex].steps[
                  this.currentStep
                ] || {
                  notes: [],
                  velocity: 0.7,
                };
                if (!currentStep.notes.includes(note)) {
                  currentStep.notes.push(note);
                }
                currentStep.velocity = velocity / 127;
                this.sequences[laneIndex].steps[this.currentStep] = currentStep;
              }
            }
          },

          updateBpm() {
            // BPM update logic (if needed)
          },

          addLane() {
            this.sequences.push({
              midiChannel: 1,
              steps: Array(16).fill(null),
            });
            this.midiInputSelections.push("");
            this.midiOutputSelections.push("");
          },

          cloneLane(index) {
            const clonedLane = JSON.parse(
              JSON.stringify(this.sequences[index]),
            );
            this.sequences.splice(index + 1, 0, clonedLane);
            this.midiInputSelections.splice(
              index + 1,
              0,
              this.midiInputSelections[index],
            );
            this.midiOutputSelections.splice(
              index + 1,
              0,
              this.midiOutputSelections[index],
            );
          },

          removeLane(index) {
            this.sequences.splice(index, 1);
            this.midiInputSelections.splice(index, 1);
            this.midiOutputSelections.splice(index, 1);
          },

          clearLane(index) {
            this.sequences[index].steps.fill(null);
          },

          clearAll() {
            this.sequences.forEach((lane) => lane.steps.fill(null));
          },

          updateMidiInput(laneIndex) {
            const inputIndex = this.midiInputSelections[laneIndex];
            if (inputIndex !== "") {
              this.midiInputs[inputIndex].onmidimessage = (message) =>
                this.handleMidiMessage(message, laneIndex);
            }
          },

          updateMidiOutput(laneIndex) {
            // MIDI output update logic (if needed)
          },

          updateMidiChannel(laneIndex) {
            // MIDI channel update logic (if needed)
          },

          allNotesOff() {
            this.sequences.forEach((lane, laneIndex) => {
              const outputIndex = this.midiOutputSelections[laneIndex];
              if (outputIndex !== "") {
                const output = this.midiOutputs[outputIndex];
                const channel = lane.midiChannel - 1;
                for (let note = 0; note < 128; note++) {
                  output.send([0x80 + channel, note, 0]); // Note Off
                }
              }
            });
          },

          getNoteNameFromMidiNumber(midiNumber) {
            const noteNames = [
              "C",
              "C#",
              "D",
              "D#",
              "E",
              "F",
              "F#",
              "G",
              "G#",
              "A",
              "A#",
              "B",
            ];
            const octave = Math.floor(midiNumber / 12) - 1;
            const noteName = noteNames[midiNumber % 12];
            return `${noteName}${octave}`;
          },
        }));
      });
    </script>
  </body>
</html>
